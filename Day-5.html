<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
//         function getUserFromFacebook(cb) {
//     // simulate server call
//     let users = [{ name: "prasad" }, { name: "karthik" }];
//     cb(users);
// }

// function getPostForUser(user, cb) {
//     // simulate API call for posts
//     let posts = [{ title: "Holiday" }, { title: "Good day" }];
//     cb(posts);
// }

// console.log("Some code Line 1");

// setTimeout(function() {
//     getUserFromFacebook(function(users) {
//         setTimeout(function() {
//             getPostForUser(users[0], function(posts) {
//                 console.log("Posts for " + users[0].name + ":");
//                 console.log(posts);
//             });
//         }, 0);
//     });
// }, 0);

// console.log("Some code Line 2");



// promises is a object whivh has a executor function
    //resolve 
    //reject

    async function getUserFromFacebook()
    {
        const prom = new Promise(function(resolve ,reject){
           // simulate server call
           let users = [{ name: "prasad" }, { name: "karthik" }];
           if (users.length>0){
            resolve("Successful Data")
           }
           else{
            reject("Some Problem")
           }
        })
        return prom;
    }
    getUserFromFacebook()
    .then(function(data){
        console.log(data)
    })
    .catch(function(error){
        console.log(error);
        })







// normal function
        function doSomething(){
            console.log("Hello")
        }
// to make it asynconous we have two ways 1. setTimeout
        // setTimeout(function(){
        //     doSomething();
        // },0);

//2.promise

function Something(){
    return new Promise((resolve, reject) => {
        if(true)
        {
            resolve("prasad")
        }
        else{
            reject("Some eoor")
    }
    })
        }

        Something()
        .then(function(data){
            console.log(data)
        })
        .catch(function(error){
            console.log(error);
        })

        // promisess call back fun are put in the micro task queue


        // event loop check first microtask queue before call back queue
        // promise call backs are execute before setTime back 
        // set time back put the fun in call back queue


        // So to create the async task we need to use promise more than setTimeout because event loop execute the microcall back first before call back queue
          

        console.log("Line 1")



        async function bigtask()
        {
            return new Promise(function(resolve,reject){
                let count=0
                for(let i=0;i<10000000;i++)
                {
                    count++
                }
                resolve(count)

                    })
        

                }

                bigtask()
                .then(function(data){
                    console.log(data)
                })
    
        console.log("Line3")






              



        //calling an api

        // one way of handling the promise is then

    //     fetch("https://jsonplaceholder.typicode.com/posts")
    //     .then(function(response){
    //         response.json()
    //         .then((data)=>{
    //             console.log(data)
    //         })
    //    })
    //     .catch((err)=>{
    //         console.log(err)
    //     })


//second way is await

  async function handlefetc(){

    let response =await fetch("https://jsonplaceholder.typicode.com/posts")
    let data = await response.json()
    console.log(data)
  }
  handlefetc()



    
    








        // reading a file 




























    </script>
    
</body>
</html>